{"version":3,"sources":["../node_modules/.pnpm/heap@0.2.7/node_modules/heap/lib/heap.js","../node_modules/.pnpm/heap@0.2.7/node_modules/heap/index.js","../src/index.ts","../src/constraint.ts","../src/tableau.ts","../src/util.ts","../src/simplex.ts","../src/branchAndCut.ts","../src/YALPS.ts"],"sourcesContent":["// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","module.exports = require('./lib/heap');\n","export * from \"./types.js\"\nexport * from \"./constraint.js\"\nexport { solve, defaultOptions } from \"./YALPS.js\"\n","import { Constraint } from \"./types.js\"\n\n/**\n * Returns a {@link Constraint} that specifies something should be less than or equal to `value`.\n * Equivalent to `{ max: value }`.\n */\nexport const lessEq = (value: number): Constraint => ({ max: value })\n\n/**\n * Returns a {@link Constraint} that specifies something should be greater than or equal to `value`.\n * Equivalent to `{ min: value }`.\n */\nexport const greaterEq = (value: number): Constraint => ({ min: value })\n\n/**\n * Returns a {@link Constraint} that specifies something should be exactly equal to `value`.\n * Equivalent to `{ equal: value }`.\n */\nexport const equalTo = (value: number): Constraint => ({ equal: value })\n\n/**\n * Returns a {@link Constraint} that specifies something should be between `lower` and `upper` (both inclusive).\n * Equivalent to `{ min: lower, max: upper }`.\n */\nexport const inRange = (lower: number, upper: number): Constraint => ({ min: lower, max: upper })\n","import { Coefficients, Model } from \"./types.js\"\n\n// The tableau representing the problem.\n// matrix is a 2D matrix (duh) represented as a 1D array.\n// The first row, 0, is the objective row.\n// The first column, 0, is the RHS column.\n// Positions are numbered starting at the first column and ending at the last row.\n// Thus, the position of the variable in the first row is width.\nexport type Tableau = {\n  readonly matrix: Float64Array\n  readonly width: number\n  readonly height: number\n  readonly positionOfVariable: Int32Array\n  readonly variableAtPosition: Int32Array\n}\n\nexport const index = (tableau: Tableau, row: number, col: number) => tableau.matrix[Math.imul(row, tableau.width) + col]\n\nexport const update = (tableau: Tableau, row: number, col: number, value: number) => {\n  tableau.matrix[Math.imul(row, tableau.width) + col] = value\n}\n\nexport type Variables<VarKey = string, ConKey = string> = readonly (readonly [VarKey, Coefficients<ConKey>])[]\n\n// A tableau with some additional context.\nexport type TableauModel<VariableKey = string, ConstraintKey = string> = {\n  readonly tableau: Tableau\n  readonly sign: number\n  readonly variables: Variables<VariableKey, ConstraintKey>\n  readonly integers: readonly number[]\n}\n\nconst convertToIterable = <K, V>(\n  seq: Iterable<readonly [K, V]> | ([K] extends [string] ? Readonly<Partial<Record<K, V>>> : never),\n) =>\n  Symbol.iterator in seq && typeof seq[Symbol.iterator] === \"function\"\n    ? seq\n    : // eslint-disable-next-line @typescript-eslint/no-unsafe-type-assertion\n      (Object.entries(seq) as Iterable<readonly [K, V]>)\n\n// prettier-ignore\nconst convertToSet = <T>(set: boolean | Iterable<T> | undefined): true | Set<T> =>\n  set === true ? true\n  : set === false ? new Set()\n  : set instanceof Set ? set\n  : new Set(set)\n\nexport const tableauModel = <VarKey = string, ConKey = string>(\n  model: Model<VarKey, ConKey>,\n): TableauModel<VarKey, ConKey> => {\n  const { direction, objective, integers, binaries } = model\n  const sign = direction === \"minimize\" ? -1.0 : 1.0\n\n  const constraintsIter = convertToIterable(model.constraints)\n  const variablesIter = convertToIterable(model.variables)\n  const variables: Variables<VarKey, ConKey> = Array.isArray(variablesIter) ? variablesIter : Array.from(variablesIter)\n\n  const binaryConstraintCol: number[] = []\n  const ints: number[] = []\n  if (integers != null || binaries != null) {\n    const binaryVariables = convertToSet(binaries)\n    const integerVariables = binaryVariables === true ? true : convertToSet(integers)\n    for (let i = 1; i <= variables.length; i++) {\n      const [key] = variables[i - 1]\n      if (binaryVariables === true || binaryVariables.has(key)) {\n        binaryConstraintCol.push(i)\n        ints.push(i)\n      } else if (integerVariables === true || integerVariables.has(key)) {\n        ints.push(i)\n      }\n    }\n  }\n\n  const constraints = new Map<ConKey, { row: number; lower: number; upper: number }>()\n  for (const [key, constraint] of constraintsIter) {\n    const bounds = constraints.get(key) ?? { row: NaN, lower: -Infinity, upper: Infinity }\n    bounds.lower = Math.max(bounds.lower, constraint.equal ?? constraint.min ?? -Infinity)\n    bounds.upper = Math.min(bounds.upper, constraint.equal ?? constraint.max ?? Infinity)\n    // if (rows.lower > rows.upper) return [\"infeasible\", NaN]\n    if (!constraints.has(key)) constraints.set(key, bounds)\n  }\n\n  let numConstraints = 1\n  for (const constraint of constraints.values()) {\n    constraint.row = numConstraints\n    numConstraints += (Number.isFinite(constraint.lower) ? 1 : 0) + (Number.isFinite(constraint.upper) ? 1 : 0)\n  }\n  const width = variables.length + 1\n  const height = numConstraints + binaryConstraintCol.length\n  const numVars = width + height\n  const matrix = new Float64Array(width * height)\n  const positionOfVariable = new Int32Array(numVars)\n  const variableAtPosition = new Int32Array(numVars)\n  const tableau = { matrix, width, height, positionOfVariable, variableAtPosition }\n\n  for (let i = 0; i < numVars; i++) {\n    positionOfVariable[i] = i\n    variableAtPosition[i] = i\n  }\n\n  for (let c = 1; c < width; c++) {\n    for (const [constraint, coef] of convertToIterable(variables[c - 1][1])) {\n      if (constraint === objective) {\n        update(tableau, 0, c, sign * coef)\n      }\n      const bounds = constraints.get(constraint)\n      if (bounds != null) {\n        if (Number.isFinite(bounds.upper)) {\n          update(tableau, bounds.row, c, coef)\n          if (Number.isFinite(bounds.lower)) {\n            update(tableau, bounds.row + 1, c, -coef)\n          }\n        } else if (Number.isFinite(bounds.lower)) {\n          update(tableau, bounds.row, c, -coef)\n        }\n      }\n    }\n  }\n\n  for (const bounds of constraints.values()) {\n    if (Number.isFinite(bounds.upper)) {\n      update(tableau, bounds.row, 0, bounds.upper)\n      if (Number.isFinite(bounds.lower)) {\n        update(tableau, bounds.row + 1, 0, -bounds.lower)\n      }\n    } else if (Number.isFinite(bounds.lower)) {\n      update(tableau, bounds.row, 0, -bounds.lower)\n    }\n  }\n\n  for (let b = 0; b < binaryConstraintCol.length; b++) {\n    const row = numConstraints + b\n    update(tableau, row, 0, 1.0)\n    update(tableau, row, binaryConstraintCol[b], 1.0)\n  }\n\n  return { tableau, sign, variables, integers: ints }\n}\n","export const roundToPrecision = (num: number, precision: number) => {\n  const rounding = Math.round(1.0 / precision)\n  return Math.round((num + Number.EPSILON) * rounding) / rounding\n}\n","import { Options, SolutionStatus } from \"./types.js\"\nimport { index, Tableau, update } from \"./tableau.js\"\nimport { roundToPrecision } from \"./util.js\"\n\nconst pivot = (tableau: Tableau, row: number, col: number) => {\n  const quotient = index(tableau, row, col)\n  const leaving = tableau.variableAtPosition[tableau.width + row]\n  const entering = tableau.variableAtPosition[col]\n  tableau.variableAtPosition[tableau.width + row] = entering\n  tableau.variableAtPosition[col] = leaving\n  tableau.positionOfVariable[leaving] = col\n  tableau.positionOfVariable[entering] = tableau.width + row\n\n  const nonZeroColumns: number[] = []\n  // (1 / quotient) * R_pivot -> R_pivot\n  for (let c = 0; c < tableau.width; c++) {\n    const value = index(tableau, row, c)\n    if (Math.abs(value) > 1e-16) {\n      update(tableau, row, c, value / quotient)\n      nonZeroColumns.push(c)\n    } else {\n      update(tableau, row, c, 0.0)\n    }\n  }\n  update(tableau, row, col, 1.0 / quotient)\n\n  // -M[r, col] * R_pivot + R_r -> R_r\n  for (let r = 0; r < tableau.height; r++) {\n    if (r === row) continue\n    const coef = index(tableau, r, col)\n    if (Math.abs(coef) > 1e-16) {\n      for (let i = 0; i < nonZeroColumns.length; i++) {\n        const c = nonZeroColumns[i]\n        update(tableau, r, c, index(tableau, r, c) - coef * index(tableau, row, c))\n      }\n      update(tableau, r, col, -coef / quotient)\n    }\n  }\n}\n\ntype PivotHistory = (readonly [row: number, col: number])[]\n\n// Checks if the simplex method has encountered a cycle.\nconst hasCycle = (history: PivotHistory, tableau: Tableau, row: number, col: number) => {\n  // This whole function seems somewhat inefficient,\n  // but there was no? noticeable impact in the benchmarks.\n  history.push([tableau.variableAtPosition[tableau.width + row], tableau.variableAtPosition[col]])\n  // the minimum length of a cycle is 6\n  for (let length = 6; length <= Math.trunc(history.length / 2); length++) {\n    let cycle = true\n    for (let i = 0; i < length; i++) {\n      const item = history.length - 1 - i\n      const [row1, col1] = history[item]\n      const [row2, col2] = history[item - length]\n      if (row1 !== row2 || col1 !== col2) {\n        cycle = false\n        break\n      }\n    }\n    if (cycle) return true\n  }\n  return false\n}\n\n// Finds the optimal solution given some basic feasible solution.\nconst phase2 = (tableau: Tableau, options: Required<Options>): [SolutionStatus, number] => {\n  const pivotHistory: PivotHistory = []\n  const { precision, maxPivots, checkCycles } = options\n  for (let iter = 0; iter < maxPivots; iter++) {\n    // Find the entering column/variable\n    let col = 0\n    let value = precision\n    for (let c = 1; c < tableau.width; c++) {\n      const reducedCost = index(tableau, 0, c)\n      if (reducedCost > value) {\n        value = reducedCost\n        col = c\n      }\n    }\n    if (col === 0) return [\"optimal\", roundToPrecision(index(tableau, 0, 0), precision)]\n\n    // Find the leaving row/variable\n    let row = 0\n    let minRatio = Infinity\n    for (let r = 1; r < tableau.height; r++) {\n      const value = index(tableau, r, col)\n      if (value <= precision) continue // pivot entry must be positive\n      const rhs = index(tableau, r, 0)\n      const ratio = rhs / value\n      if (ratio < minRatio) {\n        row = r\n        minRatio = ratio\n        if (ratio <= precision) break // ratio is 0, lowest possible\n      }\n    }\n    if (row === 0) return [\"unbounded\", col]\n\n    if (checkCycles && hasCycle(pivotHistory, tableau, row, col)) return [\"cycled\", NaN]\n\n    pivot(tableau, row, col)\n  }\n  return [\"cycled\", NaN]\n}\n\n// Transforms a tableau into a basic feasible solution.\nconst phase1 = (tableau: Tableau, options: Required<Options>): [SolutionStatus, number] => {\n  const pivotHistory: PivotHistory = []\n  const { precision, maxPivots, checkCycles } = options\n  for (let iter = 0; iter < maxPivots; iter++) {\n    // Find the leaving row/variable\n    let row = 0\n    let rhs = -precision\n    for (let r = 1; r < tableau.height; r++) {\n      const value = index(tableau, r, 0)\n      if (value < rhs) {\n        rhs = value\n        row = r\n      }\n    }\n    if (row === 0) return phase2(tableau, options)\n\n    // Find the entering column/variable\n    let col = 0\n    let maxRatio = -Infinity\n    for (let c = 1; c < tableau.width; c++) {\n      const coefficient = index(tableau, row, c)\n      if (coefficient < -precision) {\n        const ratio = -index(tableau, 0, c) / coefficient\n        if (ratio > maxRatio) {\n          maxRatio = ratio\n          col = c\n        }\n      }\n    }\n    if (col === 0) return [\"infeasible\", NaN]\n\n    if (checkCycles && hasCycle(pivotHistory, tableau, row, col)) return [\"cycled\", NaN]\n\n    pivot(tableau, row, col)\n  }\n  return [\"cycled\", NaN]\n}\n\nexport { phase1 as simplex }\n","import { Options, SolutionStatus } from \"./types.js\"\nimport { index, Tableau, TableauModel } from \"./tableau.js\"\nimport { simplex } from \"./simplex.js\"\nimport Heap from \"heap\"\n\ntype Buffer = {\n  readonly matrix: Float64Array\n  readonly positionOfVariable: Int32Array\n  readonly variableAtPosition: Int32Array\n}\n\nconst buffer = (matrixLength: number, posVarLength: number): Buffer => ({\n  matrix: new Float64Array(matrixLength),\n  positionOfVariable: new Int32Array(posVarLength),\n  variableAtPosition: new Int32Array(posVarLength),\n})\n\ntype Cut = readonly [sign: number, variable: number, value: number]\ntype Branch = readonly [eval: number, cuts: readonly Cut[]]\n\n// Creates a new tableau with additional cut constraints from a buffer.\nconst applyCuts = (\n  tableau: Tableau,\n  { matrix, positionOfVariable, variableAtPosition }: Buffer,\n  cuts: readonly Cut[],\n): Tableau => {\n  const { width, height } = tableau\n  matrix.set(tableau.matrix)\n  for (let i = 0; i < cuts.length; i++) {\n    const [sign, variable, value] = cuts[i]\n    const r = (height + i) * width\n    const pos = tableau.positionOfVariable[variable]\n    if (pos < width) {\n      matrix[r] = sign * value\n      matrix.fill(0.0, r + 1, r + width)\n      matrix[r + pos] = sign\n    } else {\n      const row = (pos - width) * width\n      matrix[r] = sign * (value - matrix[row])\n      for (let c = 1; c < width; c++) {\n        matrix[r + c] = -sign * matrix[row + c]\n      }\n    }\n  }\n\n  positionOfVariable.set(tableau.positionOfVariable)\n  variableAtPosition.set(tableau.variableAtPosition)\n  const length = width + height + cuts.length\n  for (let i = width + height; i < length; i++) {\n    positionOfVariable[i] = i\n    variableAtPosition[i] = i\n  }\n\n  return {\n    matrix: matrix.subarray(0, tableau.matrix.length + width * cuts.length),\n    width,\n    height: height + cuts.length,\n    positionOfVariable: positionOfVariable.subarray(0, length),\n    variableAtPosition: variableAtPosition.subarray(0, length),\n  }\n}\n\n// Finds the integer variable with the most fractional value.\nconst mostFractionalVar = (\n  tableau: Tableau,\n  intVars: readonly number[],\n): [variable: number, value: number, frac: number] => {\n  let highestFrac = 0.0\n  let variable = 0\n  let value = 0.0\n  for (let i = 0; i < intVars.length; i++) {\n    const intVar = intVars[i]\n    const row = tableau.positionOfVariable[intVar] - tableau.width\n    if (row < 0) continue\n\n    const val = index(tableau, row, 0)\n    const frac = Math.abs(val - Math.round(val))\n    if (frac > highestFrac) {\n      highestFrac = frac\n      variable = intVar\n      value = val\n    }\n  }\n  return [variable, value, highestFrac]\n}\n\n// Runs the branch and cut algorithm to solve an integer problem.\n// Requires the non-integer solution as input.\nexport const branchAndCut = <VarKey, ConKey>(\n  tabmod: TableauModel<VarKey, ConKey>,\n  initResult: number,\n  options: Required<Options>,\n): [TableauModel<VarKey, ConKey>, SolutionStatus, number] => {\n  const { tableau, sign, integers } = tabmod\n  const { precision, maxIterations, tolerance, timeout } = options\n  const [initVariable, initValue, initFrac] = mostFractionalVar(tableau, integers)\n  // Wow, the initial solution is integer\n  if (initFrac <= precision) return [tabmod, \"optimal\", initResult]\n\n  const branches = new Heap<Branch>((x, y) => x[0] - y[0])\n  branches.push([initResult, [[-1, initVariable, Math.ceil(initValue)]]])\n  branches.push([initResult, [[1, initVariable, Math.floor(initValue)]]])\n\n  // Set aside arrays/buffers to be reused over the course of the algorithm.\n  // One set of buffers stores the state of the current best solution.\n  // The other is used to solve the current candidate solution.\n  // The two buffers are \"swapped\" once a new best solution is found.\n  const maxExtraRows = integers.length * 2\n  const matrixLength = tableau.matrix.length + maxExtraRows * tableau.width\n  const posVarLength = tableau.positionOfVariable.length + maxExtraRows\n  let candidateBuffer = buffer(matrixLength, posVarLength)\n  let solutionBuffer = buffer(matrixLength, posVarLength)\n\n  const optimalThreshold = initResult * (1.0 - sign * tolerance)\n  const stopTime = timeout + Date.now()\n  let timedout = Date.now() >= stopTime // in case options.timeout <= 0\n  let solutionFound = false\n  let bestEval = Infinity\n  let bestTableau = tableau\n  let iter = 0\n\n  while (iter < maxIterations && !branches.empty() && bestEval >= optimalThreshold && !timedout) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const [relaxedEval, cuts] = branches.pop()!\n    if (relaxedEval > bestEval) break // the remaining branches are worse than the current best solution\n\n    const currentTableau = applyCuts(tableau, candidateBuffer, cuts)\n    const [status, result] = simplex(currentTableau, options)\n    // The initial tableau is not unbounded and adding more cuts/constraints cannot make it become unbounded\n    // assert(status !== \"unbounded\")\n    if (status === \"optimal\" && result < bestEval) {\n      const [variable, value, frac] = mostFractionalVar(currentTableau, integers)\n      if (frac <= precision) {\n        // The solution is integer\n        solutionFound = true\n        bestEval = result\n        bestTableau = currentTableau\n        const temp = solutionBuffer\n        solutionBuffer = candidateBuffer\n        candidateBuffer = temp\n      } else {\n        const cutsUpper: Cut[] = []\n        const cutsLower: Cut[] = []\n        for (let i = 0; i < cuts.length; i++) {\n          const cut = cuts[i]\n          const [dir, v] = cut\n          if (v === variable) {\n            if (dir < 0) {\n              cutsLower.push(cut)\n            } else {\n              cutsUpper.push(cut)\n            }\n          } else {\n            cutsUpper.push(cut)\n            cutsLower.push(cut)\n          }\n        }\n        cutsLower.push([1, variable, Math.floor(value)])\n        cutsUpper.push([-1, variable, Math.ceil(value)])\n        branches.push([result, cutsUpper])\n        branches.push([result, cutsLower])\n      }\n    }\n    // Otherwise, this branch's result is worse than the current best solution.\n    // This could be because this branch is infeasible or cycled.\n    // Either way, skip this branch and see if any other branches have a valid, better solution.\n    timedout = Date.now() >= stopTime\n    iter++\n  }\n\n  // Did the solver \"timeout\"?\n  const unfinished = (timedout || iter >= maxIterations) && !branches.empty() && bestEval >= optimalThreshold\n\n  // prettier-ignore\n  const status =\n    unfinished ? \"timedout\"\n    : !solutionFound ? \"infeasible\"\n    : \"optimal\"\n\n  return [{ ...tabmod, tableau: bestTableau }, status, solutionFound ? bestEval : NaN]\n}\n","import { Model, Options, SolutionStatus, Solution } from \"./types.js\"\nimport { index, tableauModel, TableauModel } from \"./tableau.js\"\nimport { roundToPrecision } from \"./util.js\"\nimport { simplex } from \"./simplex.js\"\nimport { branchAndCut } from \"./branchAndCut.js\"\n\n// Creates a solution object representing the optimal solution (if any).\nconst solution = <VarKey, ConKey>(\n  { tableau, sign, variables: vars }: TableauModel<VarKey, ConKey>,\n  status: SolutionStatus,\n  result: number,\n  { precision, includeZeroVariables }: Required<Options>,\n): Solution<VarKey> => {\n  if (status === \"optimal\" || (status === \"timedout\" && !Number.isNaN(result))) {\n    const variables: [VarKey, number][] = []\n    for (let i = 0; i < vars.length; i++) {\n      const [variable] = vars[i]\n      const row = tableau.positionOfVariable[i + 1] - tableau.width\n      const value = row >= 0 ? index(tableau, row, 0) : 0.0\n      if (value > precision) {\n        variables.push([variable, roundToPrecision(value, precision)])\n      } else if (includeZeroVariables) {\n        variables.push([variable, 0.0])\n      }\n    }\n    return {\n      status,\n      result: -sign * result,\n      variables,\n    }\n  } else if (status === \"unbounded\") {\n    const variable = tableau.variableAtPosition[result] - 1\n    return {\n      status: \"unbounded\",\n      result: sign * Infinity,\n      // prettier-ignore\n      variables:\n        (0 <= variable && variable < vars.length)\n          ? [[vars[variable][0], Infinity]]\n          : [],\n    }\n  } else {\n    // infeasible | cycled | (timedout and result is NaN)\n    return {\n      status,\n      result: NaN,\n      variables: [],\n    }\n  }\n}\n\nconst defaultOptionValues: Required<Options> = {\n  precision: 1e-8,\n  checkCycles: false,\n  maxPivots: 8192,\n  tolerance: 0,\n  timeout: Infinity,\n  maxIterations: 32768,\n  includeZeroVariables: false,\n}\n\n/**\n * The default options used by the solver.\n */\nexport const defaultOptions: Required<Options> = { ...defaultOptionValues }\n\n/**\n * Runs the solver on the given model and using the given options (if any).\n * @see {@link Model} on how to specify/create the model.\n * @see {@link Options} for the kinds of options available.\n * @see {@link Solution} for more detailed information on what is returned.\n */\nexport const solve = <VarKey = string, ConKey = string>(\n  model: Model<VarKey, ConKey>,\n  options?: Options,\n): Solution<VarKey> => {\n  const tabmod = tableauModel(model)\n  const opt = { ...defaultOptionValues, ...options }\n  const [status, result] = simplex(tabmod.tableau, opt)\n\n  if (tabmod.integers.length === 0 || status !== \"optimal\") {\n    // If a non-integer problem, return the simplex result.\n    // Otherwise, the problem has integer variables, but the initial solution is either:\n    // 1) unbounded | infeasible => all branches will also be unbounded | infeasible\n    // 2) cycled => cannot get an initial solution, return invalid solution\n    return solution(tabmod, status, result, opt)\n  } else {\n    // Integer problem and an optimal non-integer solution was found\n    const [intTabmod, intStatus, intResult] = branchAndCut(tabmod, result, opt)\n    return solution(intTabmod, intStatus, intResult, opt)\n  }\n}\n"],"mappings":"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","names":["require_heap","__commonJSMin","exports","module","Heap","defaultCmp","floor","heapify","heappop","heappush","heappushpop","heapreplace","insort","min","nlargest","nsmallest","updateItem","_siftdown","_siftup","x","y","a","lo","hi","cmp","mid","array","item","lastelt","returnitem","_ref","_i","_j","_len","_ref1","_results","_results1","pos","n","elem","result","i","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","heap","root","factory","require_heap","__commonJSMin","exports","module","index_exports","__export","defaultOptions","equalTo","greaterEq","inRange","lessEq","solve","lessEq","value","greaterEq","equalTo","inRange","lower","upper","index","tableau","row","col","update","value","convertToIterable","seq","convertToSet","set","tableauModel","model","direction","objective","integers","binaries","sign","constraintsIter","variablesIter","variables","binaryConstraintCol","ints","binaryVariables","integerVariables","i","key","constraints","constraint","bounds","numConstraints","width","height","numVars","matrix","positionOfVariable","variableAtPosition","c","coef","b","roundToPrecision","num","precision","rounding","pivot","tableau","row","col","quotient","index","leaving","entering","nonZeroColumns","c","value","update","r","coef","i","hasCycle","history","length","cycle","item","row1","col1","row2","col2","phase2","options","pivotHistory","precision","maxPivots","checkCycles","iter","reducedCost","roundToPrecision","minRatio","ratio","phase1","rhs","maxRatio","coefficient","import_heap","buffer","matrixLength","posVarLength","applyCuts","tableau","matrix","positionOfVariable","variableAtPosition","cuts","width","height","i","sign","variable","value","r","pos","row","c","length","mostFractionalVar","intVars","highestFrac","intVar","val","index","frac","branchAndCut","tabmod","initResult","options","integers","precision","maxIterations","tolerance","timeout","initVariable","initValue","initFrac","branches","Heap","x","y","maxExtraRows","candidateBuffer","solutionBuffer","optimalThreshold","stopTime","timedout","solutionFound","bestEval","bestTableau","iter","relaxedEval","currentTableau","status","result","phase1","temp","cutsUpper","cutsLower","cut","dir","v","solution","tableau","sign","vars","status","result","precision","includeZeroVariables","variables","i","variable","row","value","index","roundToPrecision","defaultOptionValues","defaultOptions","solve","model","options","tabmod","tableauModel","opt","phase1","intTabmod","intStatus","intResult","branchAndCut"]}