{"version":3,"sources":["../src/constraint.ts","../src/tableau.ts","../src/util.ts","../src/simplex.ts","../src/branchAndCut.ts","../src/YALPS.ts"],"sourcesContent":["import { Constraint } from \"./types.js\"\n\n/**\n * Returns a {@link Constraint} that specifies something should be less than or equal to `value`.\n * Equivalent to `{ max: value }`.\n */\nexport const lessEq = (value: number): Constraint => ({ max: value })\n\n/**\n * Returns a {@link Constraint} that specifies something should be greater than or equal to `value`.\n * Equivalent to `{ min: value }`.\n */\nexport const greaterEq = (value: number): Constraint => ({ min: value })\n\n/**\n * Returns a {@link Constraint} that specifies something should be exactly equal to `value`.\n * Equivalent to `{ equal: value }`.\n */\nexport const equalTo = (value: number): Constraint => ({ equal: value })\n\n/**\n * Returns a {@link Constraint} that specifies something should be between `lower` and `upper` (both inclusive).\n * Equivalent to `{ min: lower, max: upper }`.\n */\nexport const inRange = (lower: number, upper: number): Constraint => ({ min: lower, max: upper })\n","import { Coefficients, Model } from \"./types.js\"\n\n// The tableau representing the problem.\n// matrix is a 2D matrix (duh) represented as a 1D array.\n// The first row, 0, is the objective row.\n// The first column, 0, is the RHS column.\n// Positions are numbered starting at the first column and ending at the last row.\n// Thus, the position of the variable in the first row is width.\nexport type Tableau = {\n  readonly matrix: Float64Array\n  readonly width: number\n  readonly height: number\n  readonly positionOfVariable: Int32Array\n  readonly variableAtPosition: Int32Array\n}\n\nexport const index = (tableau: Tableau, row: number, col: number) => tableau.matrix[Math.imul(row, tableau.width) + col]\n\nexport const update = (tableau: Tableau, row: number, col: number, value: number) => {\n  tableau.matrix[Math.imul(row, tableau.width) + col] = value\n}\n\nexport type Variables<VarKey = string, ConKey = string> = readonly (readonly [VarKey, Coefficients<ConKey>])[]\n\n// A tableau with some additional context.\nexport type TableauModel<VariableKey = string, ConstraintKey = string> = {\n  readonly tableau: Tableau\n  readonly sign: number\n  readonly variables: Variables<VariableKey, ConstraintKey>\n  readonly integers: readonly number[]\n}\n\nconst convertToIterable = <K, V>(\n  seq: Iterable<readonly [K, V]> | ([K] extends [string] ? Readonly<Partial<Record<K, V>>> : never),\n) =>\n  Symbol.iterator in seq && typeof seq[Symbol.iterator] === \"function\"\n    ? seq\n    : // eslint-disable-next-line @typescript-eslint/no-unsafe-type-assertion\n      (Object.entries(seq) as Iterable<readonly [K, V]>)\n\n// prettier-ignore\nconst convertToSet = <T>(set: boolean | Iterable<T> | undefined): true | Set<T> =>\n  set === true ? true\n  : set === false ? new Set()\n  : set instanceof Set ? set\n  : new Set(set)\n\nexport const tableauModel = <VarKey = string, ConKey = string>(\n  model: Model<VarKey, ConKey>,\n): TableauModel<VarKey, ConKey> => {\n  const { direction, objective, integers, binaries } = model\n  const sign = direction === \"minimize\" ? -1.0 : 1.0\n\n  const constraintsIter = convertToIterable(model.constraints)\n  const variablesIter = convertToIterable(model.variables)\n  const variables: Variables<VarKey, ConKey> = Array.isArray(variablesIter) ? variablesIter : Array.from(variablesIter)\n\n  const binaryConstraintCol: number[] = []\n  const ints: number[] = []\n  if (integers != null || binaries != null) {\n    const binaryVariables = convertToSet(binaries)\n    const integerVariables = binaryVariables === true ? true : convertToSet(integers)\n    for (let i = 1; i <= variables.length; i++) {\n      const [key] = variables[i - 1]\n      if (binaryVariables === true || binaryVariables.has(key)) {\n        binaryConstraintCol.push(i)\n        ints.push(i)\n      } else if (integerVariables === true || integerVariables.has(key)) {\n        ints.push(i)\n      }\n    }\n  }\n\n  const constraints = new Map<ConKey, { row: number; lower: number; upper: number }>()\n  for (const [key, constraint] of constraintsIter) {\n    const bounds = constraints.get(key) ?? { row: NaN, lower: -Infinity, upper: Infinity }\n    bounds.lower = Math.max(bounds.lower, constraint.equal ?? constraint.min ?? -Infinity)\n    bounds.upper = Math.min(bounds.upper, constraint.equal ?? constraint.max ?? Infinity)\n    // if (rows.lower > rows.upper) return [\"infeasible\", NaN]\n    if (!constraints.has(key)) constraints.set(key, bounds)\n  }\n\n  let numConstraints = 1\n  for (const constraint of constraints.values()) {\n    constraint.row = numConstraints\n    numConstraints += (Number.isFinite(constraint.lower) ? 1 : 0) + (Number.isFinite(constraint.upper) ? 1 : 0)\n  }\n  const width = variables.length + 1\n  const height = numConstraints + binaryConstraintCol.length\n  const numVars = width + height\n  const matrix = new Float64Array(width * height)\n  const positionOfVariable = new Int32Array(numVars)\n  const variableAtPosition = new Int32Array(numVars)\n  const tableau = { matrix, width, height, positionOfVariable, variableAtPosition }\n\n  for (let i = 0; i < numVars; i++) {\n    positionOfVariable[i] = i\n    variableAtPosition[i] = i\n  }\n\n  for (let c = 1; c < width; c++) {\n    for (const [constraint, coef] of convertToIterable(variables[c - 1][1])) {\n      if (constraint === objective) {\n        update(tableau, 0, c, sign * coef)\n      }\n      const bounds = constraints.get(constraint)\n      if (bounds != null) {\n        if (Number.isFinite(bounds.upper)) {\n          update(tableau, bounds.row, c, coef)\n          if (Number.isFinite(bounds.lower)) {\n            update(tableau, bounds.row + 1, c, -coef)\n          }\n        } else if (Number.isFinite(bounds.lower)) {\n          update(tableau, bounds.row, c, -coef)\n        }\n      }\n    }\n  }\n\n  for (const bounds of constraints.values()) {\n    if (Number.isFinite(bounds.upper)) {\n      update(tableau, bounds.row, 0, bounds.upper)\n      if (Number.isFinite(bounds.lower)) {\n        update(tableau, bounds.row + 1, 0, -bounds.lower)\n      }\n    } else if (Number.isFinite(bounds.lower)) {\n      update(tableau, bounds.row, 0, -bounds.lower)\n    }\n  }\n\n  for (let b = 0; b < binaryConstraintCol.length; b++) {\n    const row = numConstraints + b\n    update(tableau, row, 0, 1.0)\n    update(tableau, row, binaryConstraintCol[b], 1.0)\n  }\n\n  return { tableau, sign, variables, integers: ints }\n}\n","export const roundToPrecision = (num: number, precision: number) => {\n  const rounding = Math.round(1.0 / precision)\n  return Math.round((num + Number.EPSILON) * rounding) / rounding\n}\n","import { Options, SolutionStatus } from \"./types.js\"\nimport { index, Tableau, update } from \"./tableau.js\"\nimport { roundToPrecision } from \"./util.js\"\n\nconst pivot = (tableau: Tableau, row: number, col: number) => {\n  const quotient = index(tableau, row, col)\n  const leaving = tableau.variableAtPosition[tableau.width + row]\n  const entering = tableau.variableAtPosition[col]\n  tableau.variableAtPosition[tableau.width + row] = entering\n  tableau.variableAtPosition[col] = leaving\n  tableau.positionOfVariable[leaving] = col\n  tableau.positionOfVariable[entering] = tableau.width + row\n\n  const nonZeroColumns: number[] = []\n  // (1 / quotient) * R_pivot -> R_pivot\n  for (let c = 0; c < tableau.width; c++) {\n    const value = index(tableau, row, c)\n    if (Math.abs(value) > 1e-16) {\n      update(tableau, row, c, value / quotient)\n      nonZeroColumns.push(c)\n    } else {\n      update(tableau, row, c, 0.0)\n    }\n  }\n  update(tableau, row, col, 1.0 / quotient)\n\n  // -M[r, col] * R_pivot + R_r -> R_r\n  for (let r = 0; r < tableau.height; r++) {\n    if (r === row) continue\n    const coef = index(tableau, r, col)\n    if (Math.abs(coef) > 1e-16) {\n      for (let i = 0; i < nonZeroColumns.length; i++) {\n        const c = nonZeroColumns[i]\n        update(tableau, r, c, index(tableau, r, c) - coef * index(tableau, row, c))\n      }\n      update(tableau, r, col, -coef / quotient)\n    }\n  }\n}\n\ntype PivotHistory = (readonly [row: number, col: number])[]\n\n// Checks if the simplex method has encountered a cycle.\nconst hasCycle = (history: PivotHistory, tableau: Tableau, row: number, col: number) => {\n  // This whole function seems somewhat inefficient,\n  // but there was no? noticeable impact in the benchmarks.\n  history.push([tableau.variableAtPosition[tableau.width + row], tableau.variableAtPosition[col]])\n  // the minimum length of a cycle is 6\n  for (let length = 6; length <= Math.trunc(history.length / 2); length++) {\n    let cycle = true\n    for (let i = 0; i < length; i++) {\n      const item = history.length - 1 - i\n      const [row1, col1] = history[item]\n      const [row2, col2] = history[item - length]\n      if (row1 !== row2 || col1 !== col2) {\n        cycle = false\n        break\n      }\n    }\n    if (cycle) return true\n  }\n  return false\n}\n\n// Finds the optimal solution given some basic feasible solution.\nconst phase2 = (tableau: Tableau, options: Required<Options>): [SolutionStatus, number] => {\n  const pivotHistory: PivotHistory = []\n  const { precision, maxPivots, checkCycles } = options\n  for (let iter = 0; iter < maxPivots; iter++) {\n    // Find the entering column/variable\n    let col = 0\n    let value = precision\n    for (let c = 1; c < tableau.width; c++) {\n      const reducedCost = index(tableau, 0, c)\n      if (reducedCost > value) {\n        value = reducedCost\n        col = c\n      }\n    }\n    if (col === 0) return [\"optimal\", roundToPrecision(index(tableau, 0, 0), precision)]\n\n    // Find the leaving row/variable\n    let row = 0\n    let minRatio = Infinity\n    for (let r = 1; r < tableau.height; r++) {\n      const value = index(tableau, r, col)\n      if (value <= precision) continue // pivot entry must be positive\n      const rhs = index(tableau, r, 0)\n      const ratio = rhs / value\n      if (ratio < minRatio) {\n        row = r\n        minRatio = ratio\n        if (ratio <= precision) break // ratio is 0, lowest possible\n      }\n    }\n    if (row === 0) return [\"unbounded\", col]\n\n    if (checkCycles && hasCycle(pivotHistory, tableau, row, col)) return [\"cycled\", NaN]\n\n    pivot(tableau, row, col)\n  }\n  return [\"cycled\", NaN]\n}\n\n// Transforms a tableau into a basic feasible solution.\nconst phase1 = (tableau: Tableau, options: Required<Options>): [SolutionStatus, number] => {\n  const pivotHistory: PivotHistory = []\n  const { precision, maxPivots, checkCycles } = options\n  for (let iter = 0; iter < maxPivots; iter++) {\n    // Find the leaving row/variable\n    let row = 0\n    let rhs = -precision\n    for (let r = 1; r < tableau.height; r++) {\n      const value = index(tableau, r, 0)\n      if (value < rhs) {\n        rhs = value\n        row = r\n      }\n    }\n    if (row === 0) return phase2(tableau, options)\n\n    // Find the entering column/variable\n    let col = 0\n    let maxRatio = -Infinity\n    for (let c = 1; c < tableau.width; c++) {\n      const coefficient = index(tableau, row, c)\n      if (coefficient < -precision) {\n        const ratio = -index(tableau, 0, c) / coefficient\n        if (ratio > maxRatio) {\n          maxRatio = ratio\n          col = c\n        }\n      }\n    }\n    if (col === 0) return [\"infeasible\", NaN]\n\n    if (checkCycles && hasCycle(pivotHistory, tableau, row, col)) return [\"cycled\", NaN]\n\n    pivot(tableau, row, col)\n  }\n  return [\"cycled\", NaN]\n}\n\nexport { phase1 as simplex }\n","import { Options, SolutionStatus } from \"./types.js\"\nimport { index, Tableau, TableauModel } from \"./tableau.js\"\nimport { simplex } from \"./simplex.js\"\nimport Heap from \"heap\"\n\ntype Buffer = {\n  readonly matrix: Float64Array\n  readonly positionOfVariable: Int32Array\n  readonly variableAtPosition: Int32Array\n}\n\nconst buffer = (matrixLength: number, posVarLength: number): Buffer => ({\n  matrix: new Float64Array(matrixLength),\n  positionOfVariable: new Int32Array(posVarLength),\n  variableAtPosition: new Int32Array(posVarLength),\n})\n\ntype Cut = readonly [sign: number, variable: number, value: number]\ntype Branch = readonly [eval: number, cuts: readonly Cut[]]\n\n// Creates a new tableau with additional cut constraints from a buffer.\nconst applyCuts = (\n  tableau: Tableau,\n  { matrix, positionOfVariable, variableAtPosition }: Buffer,\n  cuts: readonly Cut[],\n): Tableau => {\n  const { width, height } = tableau\n  matrix.set(tableau.matrix)\n  for (let i = 0; i < cuts.length; i++) {\n    const [sign, variable, value] = cuts[i]\n    const r = (height + i) * width\n    const pos = tableau.positionOfVariable[variable]\n    if (pos < width) {\n      matrix[r] = sign * value\n      matrix.fill(0.0, r + 1, r + width)\n      matrix[r + pos] = sign\n    } else {\n      const row = (pos - width) * width\n      matrix[r] = sign * (value - matrix[row])\n      for (let c = 1; c < width; c++) {\n        matrix[r + c] = -sign * matrix[row + c]\n      }\n    }\n  }\n\n  positionOfVariable.set(tableau.positionOfVariable)\n  variableAtPosition.set(tableau.variableAtPosition)\n  const length = width + height + cuts.length\n  for (let i = width + height; i < length; i++) {\n    positionOfVariable[i] = i\n    variableAtPosition[i] = i\n  }\n\n  return {\n    matrix: matrix.subarray(0, tableau.matrix.length + width * cuts.length),\n    width,\n    height: height + cuts.length,\n    positionOfVariable: positionOfVariable.subarray(0, length),\n    variableAtPosition: variableAtPosition.subarray(0, length),\n  }\n}\n\n// Finds the integer variable with the most fractional value.\nconst mostFractionalVar = (\n  tableau: Tableau,\n  intVars: readonly number[],\n): [variable: number, value: number, frac: number] => {\n  let highestFrac = 0.0\n  let variable = 0\n  let value = 0.0\n  for (let i = 0; i < intVars.length; i++) {\n    const intVar = intVars[i]\n    const row = tableau.positionOfVariable[intVar] - tableau.width\n    if (row < 0) continue\n\n    const val = index(tableau, row, 0)\n    const frac = Math.abs(val - Math.round(val))\n    if (frac > highestFrac) {\n      highestFrac = frac\n      variable = intVar\n      value = val\n    }\n  }\n  return [variable, value, highestFrac]\n}\n\n// Runs the branch and cut algorithm to solve an integer problem.\n// Requires the non-integer solution as input.\nexport const branchAndCut = <VarKey, ConKey>(\n  tabmod: TableauModel<VarKey, ConKey>,\n  initResult: number,\n  options: Required<Options>,\n): [TableauModel<VarKey, ConKey>, SolutionStatus, number] => {\n  const { tableau, sign, integers } = tabmod\n  const { precision, maxIterations, tolerance, timeout } = options\n  const [initVariable, initValue, initFrac] = mostFractionalVar(tableau, integers)\n  // Wow, the initial solution is integer\n  if (initFrac <= precision) return [tabmod, \"optimal\", initResult]\n\n  const branches = new Heap<Branch>((x, y) => x[0] - y[0])\n  branches.push([initResult, [[-1, initVariable, Math.ceil(initValue)]]])\n  branches.push([initResult, [[1, initVariable, Math.floor(initValue)]]])\n\n  // Set aside arrays/buffers to be reused over the course of the algorithm.\n  // One set of buffers stores the state of the current best solution.\n  // The other is used to solve the current candidate solution.\n  // The two buffers are \"swapped\" once a new best solution is found.\n  const maxExtraRows = integers.length * 2\n  const matrixLength = tableau.matrix.length + maxExtraRows * tableau.width\n  const posVarLength = tableau.positionOfVariable.length + maxExtraRows\n  let candidateBuffer = buffer(matrixLength, posVarLength)\n  let solutionBuffer = buffer(matrixLength, posVarLength)\n\n  const optimalThreshold = initResult * (1.0 - sign * tolerance)\n  const stopTime = timeout + Date.now()\n  let timedout = Date.now() >= stopTime // in case options.timeout <= 0\n  let solutionFound = false\n  let bestEval = Infinity\n  let bestTableau = tableau\n  let iter = 0\n\n  while (iter < maxIterations && !branches.empty() && bestEval >= optimalThreshold && !timedout) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const [relaxedEval, cuts] = branches.pop()!\n    if (relaxedEval > bestEval) break // the remaining branches are worse than the current best solution\n\n    const currentTableau = applyCuts(tableau, candidateBuffer, cuts)\n    const [status, result] = simplex(currentTableau, options)\n    // The initial tableau is not unbounded and adding more cuts/constraints cannot make it become unbounded\n    // assert(status !== \"unbounded\")\n    if (status === \"optimal\" && result < bestEval) {\n      const [variable, value, frac] = mostFractionalVar(currentTableau, integers)\n      if (frac <= precision) {\n        // The solution is integer\n        solutionFound = true\n        bestEval = result\n        bestTableau = currentTableau\n        const temp = solutionBuffer\n        solutionBuffer = candidateBuffer\n        candidateBuffer = temp\n      } else {\n        const cutsUpper: Cut[] = []\n        const cutsLower: Cut[] = []\n        for (let i = 0; i < cuts.length; i++) {\n          const cut = cuts[i]\n          const [dir, v] = cut\n          if (v === variable) {\n            if (dir < 0) {\n              cutsLower.push(cut)\n            } else {\n              cutsUpper.push(cut)\n            }\n          } else {\n            cutsUpper.push(cut)\n            cutsLower.push(cut)\n          }\n        }\n        cutsLower.push([1, variable, Math.floor(value)])\n        cutsUpper.push([-1, variable, Math.ceil(value)])\n        branches.push([result, cutsUpper])\n        branches.push([result, cutsLower])\n      }\n    }\n    // Otherwise, this branch's result is worse than the current best solution.\n    // This could be because this branch is infeasible or cycled.\n    // Either way, skip this branch and see if any other branches have a valid, better solution.\n    timedout = Date.now() >= stopTime\n    iter++\n  }\n\n  // Did the solver \"timeout\"?\n  const unfinished = (timedout || iter >= maxIterations) && !branches.empty() && bestEval >= optimalThreshold\n\n  // prettier-ignore\n  const status =\n    unfinished ? \"timedout\"\n    : !solutionFound ? \"infeasible\"\n    : \"optimal\"\n\n  return [{ ...tabmod, tableau: bestTableau }, status, solutionFound ? bestEval : NaN]\n}\n","import { Model, Options, SolutionStatus, Solution } from \"./types.js\"\nimport { index, tableauModel, TableauModel } from \"./tableau.js\"\nimport { roundToPrecision } from \"./util.js\"\nimport { simplex } from \"./simplex.js\"\nimport { branchAndCut } from \"./branchAndCut.js\"\n\n// Creates a solution object representing the optimal solution (if any).\nconst solution = <VarKey, ConKey>(\n  { tableau, sign, variables: vars }: TableauModel<VarKey, ConKey>,\n  status: SolutionStatus,\n  result: number,\n  { precision, includeZeroVariables }: Required<Options>,\n): Solution<VarKey> => {\n  if (status === \"optimal\" || (status === \"timedout\" && !Number.isNaN(result))) {\n    const variables: [VarKey, number][] = []\n    for (let i = 0; i < vars.length; i++) {\n      const [variable] = vars[i]\n      const row = tableau.positionOfVariable[i + 1] - tableau.width\n      const value = row >= 0 ? index(tableau, row, 0) : 0.0\n      if (value > precision) {\n        variables.push([variable, roundToPrecision(value, precision)])\n      } else if (includeZeroVariables) {\n        variables.push([variable, 0.0])\n      }\n    }\n    return {\n      status,\n      result: -sign * result,\n      variables,\n    }\n  } else if (status === \"unbounded\") {\n    const variable = tableau.variableAtPosition[result] - 1\n    return {\n      status: \"unbounded\",\n      result: sign * Infinity,\n      // prettier-ignore\n      variables:\n        (0 <= variable && variable < vars.length)\n          ? [[vars[variable][0], Infinity]]\n          : [],\n    }\n  } else {\n    // infeasible | cycled | (timedout and result is NaN)\n    return {\n      status,\n      result: NaN,\n      variables: [],\n    }\n  }\n}\n\nconst defaultOptionValues: Required<Options> = {\n  precision: 1e-8,\n  checkCycles: false,\n  maxPivots: 8192,\n  tolerance: 0,\n  timeout: Infinity,\n  maxIterations: 32768,\n  includeZeroVariables: false,\n}\n\n/**\n * The default options used by the solver.\n */\nexport const defaultOptions: Required<Options> = { ...defaultOptionValues }\n\n/**\n * Runs the solver on the given model and using the given options (if any).\n * @see {@link Model} on how to specify/create the model.\n * @see {@link Options} for the kinds of options available.\n * @see {@link Solution} for more detailed information on what is returned.\n */\nexport const solve = <VarKey = string, ConKey = string>(\n  model: Model<VarKey, ConKey>,\n  options?: Options,\n): Solution<VarKey> => {\n  const tabmod = tableauModel(model)\n  const opt = { ...defaultOptionValues, ...options }\n  const [status, result] = simplex(tabmod.tableau, opt)\n\n  if (tabmod.integers.length === 0 || status !== \"optimal\") {\n    // If a non-integer problem, return the simplex result.\n    // Otherwise, the problem has integer variables, but the initial solution is either:\n    // 1) unbounded | infeasible => all branches will also be unbounded | infeasible\n    // 2) cycled => cannot get an initial solution, return invalid solution\n    return solution(tabmod, status, result, opt)\n  } else {\n    // Integer problem and an optimal non-integer solution was found\n    const [intTabmod, intStatus, intResult] = branchAndCut(tabmod, result, opt)\n    return solution(intTabmod, intStatus, intResult, opt)\n  }\n}\n"],"mappings":"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","names":["lessEq","value","greaterEq","equalTo","inRange","lower","upper","index","tableau","row","col","update","value","convertToIterable","seq","convertToSet","set","tableauModel","model","direction","objective","integers","binaries","sign","constraintsIter","variablesIter","variables","binaryConstraintCol","ints","binaryVariables","integerVariables","i","key","constraints","constraint","bounds","numConstraints","width","height","numVars","matrix","positionOfVariable","variableAtPosition","c","coef","b","roundToPrecision","num","precision","rounding","pivot","tableau","row","col","quotient","index","leaving","entering","nonZeroColumns","c","value","update","r","coef","i","hasCycle","history","length","cycle","item","row1","col1","row2","col2","phase2","options","pivotHistory","precision","maxPivots","checkCycles","iter","reducedCost","roundToPrecision","minRatio","ratio","phase1","rhs","maxRatio","coefficient","Heap","buffer","matrixLength","posVarLength","applyCuts","tableau","matrix","positionOfVariable","variableAtPosition","cuts","width","height","i","sign","variable","value","r","pos","row","c","length","mostFractionalVar","intVars","highestFrac","intVar","val","index","frac","branchAndCut","tabmod","initResult","options","integers","precision","maxIterations","tolerance","timeout","initVariable","initValue","initFrac","branches","x","y","maxExtraRows","candidateBuffer","solutionBuffer","optimalThreshold","stopTime","timedout","solutionFound","bestEval","bestTableau","iter","relaxedEval","currentTableau","status","result","phase1","temp","cutsUpper","cutsLower","cut","dir","v","solution","tableau","sign","vars","status","result","precision","includeZeroVariables","variables","i","variable","row","value","index","roundToPrecision","defaultOptionValues","defaultOptions","solve","model","options","tabmod","tableauModel","opt","phase1","intTabmod","intStatus","intResult","branchAndCut"]}